{"id":"content/blog/decisions.js","dependencies":[{"name":"/home/ericloux/Desktop/code/portfolio/package.json","includedInParent":true,"mtime":1565309385158}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decisions = decisions;\n\nfunction decisions() {\n  var content = \"\";\n  content += \"\\n    <h3>\\n    Decisions and Addition\\n    </h3>\\n\\n    To this point, we have looked at many gates that have two inputs and one output. These form a basis from which we can create more complex \\n    operators, but which ones are useful? As we said before, there are 256 different gates that we can create with three inputs. Surely we don't \\n    need all of these.<br><br>\\n\\n    Just as And, Or, and Not are the primary two-input operators, not all three-input operators need to be clearly defined. Most can be easily \\n    specified by combining the inputs into various And, Or, and Not gates. The most important is called a multiplexor, which allows for branching. \\n    For this gate, we have a Control input, as well as our I1 and I2. When the Control bit is set to true, then the output is equal to I1. If the \\n    control bit is false, then the output is equal to I2. Here is the truth table for this function:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>Control</th>\\t\\n                <th>I1</th>\\t\\n                <th>I2</th>\\t\\n                <th>Out</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n    </table><br>\\n\\n    Can we make this function from our simpler gates alone? We sure can! To do so, let's look at breaking it down into smaller pieces and then try \\n    and piece them together. First, we know that if Control is 0 then Out will be equal to I1. We have an operation that returns true only if one \\n    input is true - the Only gate. To reduce confusion, we will call it by its other name, And Not. Here is the truth table for that gate applied \\n    to Control and I1:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>Control</th>\\t\\n                <th>I1</th>\\t\\n                <th>Out</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n    </table><br>\\n\\n    Likewise, if we want a function that is true only if Control and I2 are both true. That's our And function, shown again here:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>Control</th>\\t\\n                <th>I2</th>\\t\\n                <th>Out</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n    </table><br>\\n\\n    Now, how can we combine these two charts? If we use And, then the result will always be zero as the Control input would need to be 1 and 0 at \\n    the same time. If we use Or, though, then it works perfectly! Here is the full truth table with all three inputs, along with both of the interim \\n    functions, then finally the combination:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>Control</th>\\t\\n                <th>I1</th>\\t\\n                <th>I2</th>\\t\\n                <th>I1 And Not Control</th>\\t\\n                <th>I2 And Control</th>\\t\\n                <th>(I1 And Not Control) Or (I2 And Control)</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n    </table><br>\\n\\n    We've done it! Although its application may not be apparent at first, this allows us to start making decisions with our circuits. This feature \\n    will become incredibly useful at higher levels of computing as it allows code to branch, which is incredibly useful to create complex programs.\\n    <br><br>\\n\\n    In addition to the multiplexer, we can also use our gates to create chips that can begin to perform mathematical operations. The simplest is \\n    called a half adder, and it takes two inputs and provides the result of adding then. Although I haven't \\n    introduced binary completely yet, consider that there \\n    are only three results when adding a combination of 1s and 0s: 0, 1, or 2. Since a single output can only represent a 1 or 0, how do we represent \\n    a 2? The answer: add more outputs! If we have another output that's true when the sum is 2, then we can track that information as well. What's \\n    more, if both outputs are on, then we have an output that represents 2 plus an output that represents 1, which means we can also indicate an \\n    output of 3 if both are on. Here is a table showing this information:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>2's </th>\\t\\n                <th>1's Output</th>\\t\\n                <th>Decimal </th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>2</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>3</td>\\n        </tr>\\n    </table><br>\\n\\n    If we keep adding more outputs, then we can double the number of possible outputs. This is the basis for binary, which will be explored deeper \\n    in a subsequent article.<br><br>\\n\\n    However, at this point, we're trying to make a gate that takes two numbers and adds them. We'll call our two output gates Sum and Carry. Sum \\n    represents the ones place in the table above, and Carry represents whether we need to carry our answer over. Here is a truth table for the gate \\n    that we need to create:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>I1</th>\\t\\n                <th>I2</th>\\t\\n                <th>Sum</th>\\t\\n                <th>Carry</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n    </table><br>\\n\\n    Those operations might look familiar. That's because Sum is just an Xor gate, and Carry is an And gate. We've already built these, and now \\n    we've shown how they can be combined into a chip that starts doing math! And since the highest number we can represent is 2, we could even add \\n    another input to completely utilize both output bits to their fullest potential. Since the other chip was known as a half adder, this three-input \\n    version is called a full adder. Here is a truth table for it:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>I1</th>\\t\\n                <th>I2</th>\\t\\n                <th>I3</th>\\t\\n                <th>Sum</th>\\t\\n                <th>Carry</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n    </table><br>\\n\\n    The implementation of this chip is a bit more complex. Sum is true if exactly one input is true, or if all three are. Carry is true if at least \\n    two inputs are true. How can we create a function that represents that? Let's see what happens to our truth table when we connect inputs I2 and \\n    I3 to a half adder:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>I1</th>\\t\\n                <th>I2</th>\\t\\n                <th>I3</th>\\t\\n                <th>Sum(I2,I3)</th>\\t\\n                <th>Carry(I2,I3)</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n    </table><br>\\n\\n    The first half of the table is dead on, but the second half is almost completely wrong. But, if you apply Xor to I1 and the Sum output:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>I1</th>\\t\\n                <th>Sum(I2,I3)</th>\\t\\n                <th>Xor</th>\\t\\n                <th>Sum(I1,I2,I3)</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n    </table><br>\\n\\n    Now, the output matches the intended result for the full adder's Sum output. We're halfway there! At least, we would be if the Carry gate \\n    were as easy to model. However, think about the way the gate was described before: if at least two of the inputs are true, then Carry is true. \\n    That's easy to represent - if (I1 and I2) or (I1 and I3) or (I2 and I3) are true, then Carry is true. Let's draw another truth table to show \\n    this relationship with its intermediate steps:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>I1</th>\\t\\n                <th>I2</th>\\t\\n                <th>I3</th>\\t\\n                <th>And(I1, I2)</th>\\t\\n                <th>And(I1, I3)</th>\\t\\n                <th>And(I2, I3)</th>\\t\\n                <th>Or(And(I1, I2), And(I1, I3)</th>\\t\\n                <th>Or(Or(And(I1, I2), And(I1, I3), And(I2,I3)))</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>0</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n        <tr>\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\t\\t\\n            <td>1</td>\\n        </tr>\\n    </table><br>\\n\\n    There we go! Now if we combine what we've done, we have a full adder chip that can add three binary numbers!<br><br>\\n\\n    Naturally, though, how often do you need to add a combination of three 1s and 0s? Not very often, admittedly. So, what can we do to start \\n    making this more useful? Unfortunately, that answer will have to wait until the next article. First, though, we'll need to take another \\n    interlude where we more deeply examine the binary number system. After doing so, the answer might become intuitive, but if not, it too will \\n    be explained in time.<br><br><br><br>\\n    \";\n  document.getElementsByClassName(\"content\")[0].innerHTML = content;\n}"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":8,"column":0},"source":"content/blog/decisions.js","original":{"line":1,"column":0}},{"name":"decisions","generated":{"line":8,"column":9},"source":"content/blog/decisions.js","original":{"line":1,"column":9}},{"generated":{"line":8,"column":18},"source":"content/blog/decisions.js","original":{"line":1,"column":0}},{"generated":{"line":8,"column":21},"source":"content/blog/decisions.js","original":{"line":1,"column":21}},{"generated":{"line":9,"column":0},"source":"content/blog/decisions.js","original":{"line":2,"column":4}},{"name":"content","generated":{"line":9,"column":6},"source":"content/blog/decisions.js","original":{"line":2,"column":8}},{"generated":{"line":9,"column":13},"source":"content/blog/decisions.js","original":{"line":2,"column":15}},{"generated":{"line":9,"column":16},"source":"content/blog/decisions.js","original":{"line":2,"column":18}},{"generated":{"line":9,"column":18},"source":"content/blog/decisions.js","original":{"line":2,"column":4}},{"name":"content","generated":{"line":10,"column":0},"source":"content/blog/decisions.js","original":{"line":4,"column":4}},{"name":"content","generated":{"line":10,"column":2},"source":"content/blog/decisions.js","original":{"line":4,"column":4}},{"generated":{"line":10,"column":9},"source":"content/blog/decisions.js","original":{"line":4,"column":11}},{"generated":{"line":10,"column":18619},"source":"content/blog/decisions.js","original":{"line":4,"column":4}},{"name":"document","generated":{"line":11,"column":0},"source":"content/blog/decisions.js","original":{"line":623,"column":4}},{"name":"document","generated":{"line":11,"column":2},"source":"content/blog/decisions.js","original":{"line":623,"column":4}},{"generated":{"line":11,"column":10},"source":"content/blog/decisions.js","original":{"line":623,"column":12}},{"name":"getElementsByClassName","generated":{"line":11,"column":11},"source":"content/blog/decisions.js","original":{"line":623,"column":13}},{"generated":{"line":11,"column":33},"source":"content/blog/decisions.js","original":{"line":623,"column":4}},{"generated":{"line":11,"column":34},"source":"content/blog/decisions.js","original":{"line":623,"column":36}},{"generated":{"line":11,"column":43},"source":"content/blog/decisions.js","original":{"line":623,"column":4}},{"generated":{"line":11,"column":45},"source":"content/blog/decisions.js","original":{"line":623,"column":47}},{"generated":{"line":11,"column":46},"source":"content/blog/decisions.js","original":{"line":623,"column":4}},{"name":"innerHTML","generated":{"line":11,"column":48},"source":"content/blog/decisions.js","original":{"line":623,"column":50}},{"generated":{"line":11,"column":57},"source":"content/blog/decisions.js","original":{"line":623,"column":4}},{"name":"content","generated":{"line":11,"column":60},"source":"content/blog/decisions.js","original":{"line":623,"column":62}},{"generated":{"line":11,"column":67},"source":"content/blog/decisions.js","original":{"line":623,"column":4}},{"generated":{"line":12,"column":0},"source":"content/blog/decisions.js","original":{"line":624,"column":1}}],"sources":{"content/blog/decisions.js":"function decisions() {\n    let content = \"\";\n\n    content += `\n    <h3>\n    Decisions and Addition\n    </h3>\n\n    To this point, we have looked at many gates that have two inputs and one output. These form a basis from which we can create more complex \n    operators, but which ones are useful? As we said before, there are 256 different gates that we can create with three inputs. Surely we don't \n    need all of these.<br><br>\n\n    Just as And, Or, and Not are the primary two-input operators, not all three-input operators need to be clearly defined. Most can be easily \n    specified by combining the inputs into various And, Or, and Not gates. The most important is called a multiplexor, which allows for branching. \n    For this gate, we have a Control input, as well as our I1 and I2. When the Control bit is set to true, then the output is equal to I1. If the \n    control bit is false, then the output is equal to I2. Here is the truth table for this function:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>Control</th>\t\n                <th>I1</th>\t\n                <th>I2</th>\t\n                <th>Out</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n    </table><br>\n\n    Can we make this function from our simpler gates alone? We sure can! To do so, let's look at breaking it down into smaller pieces and then try \n    and piece them together. First, we know that if Control is 0 then Out will be equal to I1. We have an operation that returns true only if one \n    input is true - the Only gate. To reduce confusion, we will call it by its other name, And Not. Here is the truth table for that gate applied \n    to Control and I1:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>Control</th>\t\n                <th>I1</th>\t\n                <th>Out</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\n        </tr>\n    </table><br>\n\n    Likewise, if we want a function that is true only if Control and I2 are both true. That's our And function, shown again here:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>Control</th>\t\n                <th>I2</th>\t\n                <th>Out</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n    </table><br>\n\n    Now, how can we combine these two charts? If we use And, then the result will always be zero as the Control input would need to be 1 and 0 at \n    the same time. If we use Or, though, then it works perfectly! Here is the full truth table with all three inputs, along with both of the interim \n    functions, then finally the combination:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>Control</th>\t\n                <th>I1</th>\t\n                <th>I2</th>\t\n                <th>I1 And Not Control</th>\t\n                <th>I2 And Control</th>\t\n                <th>(I1 And Not Control) Or (I2 And Control)</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n    </table><br>\n\n    We've done it! Although its application may not be apparent at first, this allows us to start making decisions with our circuits. This feature \n    will become incredibly useful at higher levels of computing as it allows code to branch, which is incredibly useful to create complex programs.\n    <br><br>\n\n    In addition to the multiplexer, we can also use our gates to create chips that can begin to perform mathematical operations. The simplest is \n    called a half adder, and it takes two inputs and provides the result of adding then. Although I haven't \n    introduced binary completely yet, consider that there \n    are only three results when adding a combination of 1s and 0s: 0, 1, or 2. Since a single output can only represent a 1 or 0, how do we represent \n    a 2? The answer: add more outputs! If we have another output that's true when the sum is 2, then we can track that information as well. What's \n    more, if both outputs are on, then we have an output that represents 2 plus an output that represents 1, which means we can also indicate an \n    output of 3 if both are on. Here is a table showing this information:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>2's </th>\t\n                <th>1's Output</th>\t\n                <th>Decimal </th>\n            </tr>\n        </thead>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>2</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>3</td>\n        </tr>\n    </table><br>\n\n    If we keep adding more outputs, then we can double the number of possible outputs. This is the basis for binary, which will be explored deeper \n    in a subsequent article.<br><br>\n\n    However, at this point, we're trying to make a gate that takes two numbers and adds them. We'll call our two output gates Sum and Carry. Sum \n    represents the ones place in the table above, and Carry represents whether we need to carry our answer over. Here is a truth table for the gate \n    that we need to create:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>I1</th>\t\n                <th>I2</th>\t\n                <th>Sum</th>\t\n                <th>Carry</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\n        </tr>\n    </table><br>\n\n    Those operations might look familiar. That's because Sum is just an Xor gate, and Carry is an And gate. We've already built these, and now \n    we've shown how they can be combined into a chip that starts doing math! And since the highest number we can represent is 2, we could even add \n    another input to completely utilize both output bits to their fullest potential. Since the other chip was known as a half adder, this three-input \n    version is called a full adder. Here is a truth table for it:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>I1</th>\t\n                <th>I2</th>\t\n                <th>I3</th>\t\n                <th>Sum</th>\t\n                <th>Carry</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n    </table><br>\n\n    The implementation of this chip is a bit more complex. Sum is true if exactly one input is true, or if all three are. Carry is true if at least \n    two inputs are true. How can we create a function that represents that? Let's see what happens to our truth table when we connect inputs I2 and \n    I3 to a half adder:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>I1</th>\t\n                <th>I2</th>\t\n                <th>I3</th>\t\n                <th>Sum(I2,I3)</th>\t\n                <th>Carry(I2,I3)</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\n        </tr>\n    </table><br>\n\n    The first half of the table is dead on, but the second half is almost completely wrong. But, if you apply Xor to I1 and the Sum output:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>I1</th>\t\n                <th>Sum(I2,I3)</th>\t\n                <th>Xor</th>\t\n                <th>Sum(I1,I2,I3)</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n    </table><br>\n\n    Now, the output matches the intended result for the full adder's Sum output. We're halfway there! At least, we would be if the Carry gate \n    were as easy to model. However, think about the way the gate was described before: if at least two of the inputs are true, then Carry is true. \n    That's easy to represent - if (I1 and I2) or (I1 and I3) or (I2 and I3) are true, then Carry is true. Let's draw another truth table to show \n    this relationship with its intermediate steps:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>I1</th>\t\n                <th>I2</th>\t\n                <th>I3</th>\t\n                <th>And(I1, I2)</th>\t\n                <th>And(I1, I3)</th>\t\n                <th>And(I2, I3)</th>\t\n                <th>Or(And(I1, I2), And(I1, I3)</th>\t\n                <th>Or(Or(And(I1, I2), And(I1, I3), And(I2,I3)))</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>0</td>\t\t\n            <td>0</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\t\t\n            <td>1</td>\n        </tr>\n    </table><br>\n\n    There we go! Now if we combine what we've done, we have a full adder chip that can add three binary numbers!<br><br>\n\n    Naturally, though, how often do you need to add a combination of three 1s and 0s? Not very often, admittedly. So, what can we do to start \n    making this more useful? Unfortunately, that answer will have to wait until the next article. First, though, we'll need to take another \n    interlude where we more deeply examine the binary number system. After doing so, the answer might become intuitive, but if not, it too will \n    be explained in time.<br><br><br><br>\n    `;\n\n    document.getElementsByClassName(\"content\")[0].innerHTML = content;\n}\n\nexport {decisions};"},"lineCount":null}},"error":null,"hash":"e444ac26ce4557772a8ca0ce1125edf2","cacheData":{"env":{}}}