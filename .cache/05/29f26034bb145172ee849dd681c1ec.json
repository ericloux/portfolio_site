{"id":"content/blog/binary.js","dependencies":[{"name":"/home/ericloux/Desktop/code/portfolio/package.json","includedInParent":true,"mtime":1565309385158}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.boolean = boolean;\n\nfunction boolean() {\n  var content = \"\";\n  content += \"\\n    <h3>Binary Numbers</h3>\\n\\n    As we've progressed upwards with our examination of what makes a computer, the scene has changed a bit. At first, we were examining circuits in \\n    terms of on and off state. Once those were functioning correctly, then we could step back and think of them as operations rather than physical \\n    constructs, doing logical operations with ones and zeroes. Then, we saw how to extend those operations and start to do addition and decision \\n    making. However, that addition is limited to only add numbers up to three. Let's examine how we can extend that further!<br><br>\\n\\n    If you remember, our adder outputs two binary numbers. Based on the combination of these numbers, we can have 0 through 3 represented as 00, 01, \\n    10, and 11 respectively. So, if we add another digit, then we would double the combinations, and therefore double the numbers we could represent. \\n    Each new digit represents a number that's a multiple of two. The rightmost place represents 1. The next digit to the left represents 2, then 4, \\n    then 8, and so on. This is the basis for binary numbers. <br><br>\\n\\n    It may not be intuitive, but we can add add and subtract these just like normal decimal numbers. The difference is that we carry or borrow with \\n    twos instead of tens. For example, 111 + 1 would become 1000, or 1011 + 10 would be 1101. Converting these to decimal, we see that they're also \\n    true: 7 + 8 = 8, and 11 + 2 = 13. <br><br>\\n\\n    Of course, these are just for positive numbers. If we can represent negative numbers in a sensible way, then by adding them together, we can \\n    perform subtraction with the same process of just adding bit by bit.<br><br>\\n\\n    The first idea would be just to flip the bits. So, if 11 is 3, then 00 would be -3. You can tell the issue with that - 00 is already zero, and \\n    that's kind of an important number. The solution would be to make each number a fixed number of digits long. For example, instead of representing \\n    3 as 11, you might represent it as 0011. Then, if we reverse the bits, we get 1100 to represent -3. This means, though, that half of the numbers \\n    would be negative, so any number that starts with 1 is negative, and any number starting with 0 is positive. But what happens if we add 1100 and \\n    0011 together? We get 1111 when we should get zero. Of course, if we also flip 1111, then we get 0000, which is zero. So, somehow we ended up with \\n    negative zero. This obviously makes no sense.<br><br>\\n\\n    So, how can we fix this? If we add some other numbers and negatives, then we can see a pattern. Let's add -3 to each number and look at the \\n    results:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>Decimal</th>\\n                <th>Positive Binary</th>\\n                <th>-3 in Binary</th>\\n                <th>Binary Result</th>\\n                <th>Decimal Result</th>\\n                <th>Actual Value</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>7</td>\\n            <td>0111</td>\\n            <td>1100</td>\\n            <td>0011</td>\\n            <td>3</td>\\n            <td>4</tr>\\n        <tr>\\n            <td>6</td>\\n            <td>0110</td>\\n            <td>1100</td>\\n            <td>0010</td>\\n            <td>2</td>\\n            <td>3</tr>\\n        <tr>\\n            <td>5</td>\\n            <td>0101</td>\\n            <td>1100</td>\\n            <td>0001</td>\\n            <td>1</td>\\n            <td>2</tr>\\n        <tr>\\n            <td>4</td>\\n            <td>0100</td>\\n            <td>1100</td>\\n            <td>0000</td>\\n            <td>0</td>\\n            <td>1</tr>\\n        <tr>\\n            <td>3</td>\\n            <td>0011</td>\\n            <td>1100</td>\\n            <td>1111</td>\\n            <td>-0</td>\\n            <td>0</tr>\\n        <tr>\\n            <td>2</td>\\n            <td>0010</td>\\n            <td>1100</td>\\n            <td>1110</td>\\n            <td>-1</td>\\n            <td>-1</tr>\\n        <tr>\\n            <td>1</td>\\n            <td>0001</td>\\n            <td>1100</td>\\n            <td>1101</td>\\n            <td>-2</td>\\n            <td>-2</tr>\\n        <tr>\\n            <td>0</td>\\n            <td>0000</td>\\n            <td>1100</td>\\n            <td>1100</td>\\n            <td>-3</td>\\n            <td>-3</td>\\n        </tr>\\n    </table>\\n\\n    Each of the positive numbers is off by 1, and there's still that negative 0 in the mix. So, what if we add one to each negative number? That way \\n    1111 would become -1 rather than -0, it would correct the error with the negative numbers. Recreating the chart above with this new method, we \\n    get the following:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>Decimal</th>\\n                <th>Positive Binary</th>\\n                <th>-3 in Binary</th>\\n                <th>Binary Result</th>\\n                <th>Decimal Result</th>\\n                <th>Actual Value</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>7</td>\\n            <td>0111</td>\\n            <td>1101</td>\\n            <td>0100</td>\\n            <td>3</td>\\n            <td>4</tr>\\n        <tr>\\n            <td>6</td>\\n            <td>0110</td>\\n            <td>1101</td>\\n            <td>0011</td>\\n            <td>2</td>\\n            <td>3</tr>\\n        <tr>\\n            <td>5</td>\\n            <td>0101</td>\\n            <td>1101</td>\\n            <td>0010</td>\\n            <td>1</td>\\n            <td>2</tr>\\n        <tr>\\n            <td>4</td>\\n            <td>0100</td>\\n            <td>1101</td>\\n            <td>0001</td>\\n            <td>0</td>\\n            <td>1</tr>\\n        <tr>\\n            <td>3</td>\\n            <td>0011</td>\\n            <td>1101</td>\\n            <td>0000</td>\\n            <td>-0</td>\\n            <td>0</tr>\\n        <tr>\\n            <td>2</td>\\n            <td>0010</td>\\n            <td>1101</td>\\n            <td>1111</td>\\n            <td>-1</td>\\n            <td>-1</tr>\\n        <tr>\\n            <td>1</td>\\n            <td>0001</td>\\n            <td>1101</td>\\n            <td>1110</td>\\n            <td>-2</td>\\n            <td>-2</tr>\\n        <tr>\\n            <td>0</td>\\n            <td>0000</td>\\n            <td>1101</td>\\n            <td>1101</td>\\n            <td>-3</td>\\n            <td>-3</td>\\n        </tr>\\n    </table>\\n\\n    It now works perfectly! We've just made numbers much easier to add in binary. Now instead of having two separate circuits to add and subtract, \\n    all we need to do is to negate each bit in the number being subtracted and add one to it, then we can add the numbers and we have subtraction!<br><br>\\n\\n    This method of representing binary numbers is also known as the \\\"2's Complement\\\" method. It's by far the most common way of representing negative \\n    binary numbers due to the reasons presented here.<br><br><br>\\n    \";\n  document.getElementsByClassName(\"content\")[0].innerHTML = content;\n}"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":8,"column":0},"source":"content/blog/binary.js","original":{"line":1,"column":0}},{"name":"boolean","generated":{"line":8,"column":9},"source":"content/blog/binary.js","original":{"line":1,"column":9}},{"generated":{"line":8,"column":16},"source":"content/blog/binary.js","original":{"line":1,"column":0}},{"generated":{"line":8,"column":19},"source":"content/blog/binary.js","original":{"line":1,"column":19}},{"generated":{"line":9,"column":0},"source":"content/blog/binary.js","original":{"line":2,"column":4}},{"name":"content","generated":{"line":9,"column":6},"source":"content/blog/binary.js","original":{"line":2,"column":8}},{"generated":{"line":9,"column":13},"source":"content/blog/binary.js","original":{"line":2,"column":15}},{"generated":{"line":9,"column":16},"source":"content/blog/binary.js","original":{"line":2,"column":18}},{"generated":{"line":9,"column":18},"source":"content/blog/binary.js","original":{"line":2,"column":4}},{"name":"content","generated":{"line":10,"column":0},"source":"content/blog/binary.js","original":{"line":4,"column":4}},{"name":"content","generated":{"line":10,"column":2},"source":"content/blog/binary.js","original":{"line":4,"column":4}},{"generated":{"line":10,"column":9},"source":"content/blog/binary.js","original":{"line":4,"column":11}},{"generated":{"line":10,"column":6978},"source":"content/blog/binary.js","original":{"line":4,"column":4}},{"name":"document","generated":{"line":11,"column":0},"source":"content/blog/binary.js","original":{"line":185,"column":4}},{"name":"document","generated":{"line":11,"column":2},"source":"content/blog/binary.js","original":{"line":185,"column":4}},{"generated":{"line":11,"column":10},"source":"content/blog/binary.js","original":{"line":185,"column":12}},{"name":"getElementsByClassName","generated":{"line":11,"column":11},"source":"content/blog/binary.js","original":{"line":185,"column":13}},{"generated":{"line":11,"column":33},"source":"content/blog/binary.js","original":{"line":185,"column":4}},{"generated":{"line":11,"column":34},"source":"content/blog/binary.js","original":{"line":185,"column":36}},{"generated":{"line":11,"column":43},"source":"content/blog/binary.js","original":{"line":185,"column":4}},{"generated":{"line":11,"column":45},"source":"content/blog/binary.js","original":{"line":185,"column":47}},{"generated":{"line":11,"column":46},"source":"content/blog/binary.js","original":{"line":185,"column":4}},{"name":"innerHTML","generated":{"line":11,"column":48},"source":"content/blog/binary.js","original":{"line":185,"column":50}},{"generated":{"line":11,"column":57},"source":"content/blog/binary.js","original":{"line":185,"column":4}},{"name":"content","generated":{"line":11,"column":60},"source":"content/blog/binary.js","original":{"line":185,"column":62}},{"generated":{"line":11,"column":67},"source":"content/blog/binary.js","original":{"line":185,"column":4}},{"generated":{"line":12,"column":0},"source":"content/blog/binary.js","original":{"line":186,"column":1}}],"sources":{"content/blog/binary.js":"function boolean() {\n    let content = \"\";\n\n    content += `\n    <h3>Binary Numbers</h3>\n\n    As we've progressed upwards with our examination of what makes a computer, the scene has changed a bit. At first, we were examining circuits in \n    terms of on and off state. Once those were functioning correctly, then we could step back and think of them as operations rather than physical \n    constructs, doing logical operations with ones and zeroes. Then, we saw how to extend those operations and start to do addition and decision \n    making. However, that addition is limited to only add numbers up to three. Let's examine how we can extend that further!<br><br>\n\n    If you remember, our adder outputs two binary numbers. Based on the combination of these numbers, we can have 0 through 3 represented as 00, 01, \n    10, and 11 respectively. So, if we add another digit, then we would double the combinations, and therefore double the numbers we could represent. \n    Each new digit represents a number that's a multiple of two. The rightmost place represents 1. The next digit to the left represents 2, then 4, \n    then 8, and so on. This is the basis for binary numbers. <br><br>\n\n    It may not be intuitive, but we can add add and subtract these just like normal decimal numbers. The difference is that we carry or borrow with \n    twos instead of tens. For example, 111 + 1 would become 1000, or 1011 + 10 would be 1101. Converting these to decimal, we see that they're also \n    true: 7 + 8 = 8, and 11 + 2 = 13. <br><br>\n\n    Of course, these are just for positive numbers. If we can represent negative numbers in a sensible way, then by adding them together, we can \n    perform subtraction with the same process of just adding bit by bit.<br><br>\n\n    The first idea would be just to flip the bits. So, if 11 is 3, then 00 would be -3. You can tell the issue with that - 00 is already zero, and \n    that's kind of an important number. The solution would be to make each number a fixed number of digits long. For example, instead of representing \n    3 as 11, you might represent it as 0011. Then, if we reverse the bits, we get 1100 to represent -3. This means, though, that half of the numbers \n    would be negative, so any number that starts with 1 is negative, and any number starting with 0 is positive. But what happens if we add 1100 and \n    0011 together? We get 1111 when we should get zero. Of course, if we also flip 1111, then we get 0000, which is zero. So, somehow we ended up with \n    negative zero. This obviously makes no sense.<br><br>\n\n    So, how can we fix this? If we add some other numbers and negatives, then we can see a pattern. Let's add -3 to each number and look at the \n    results:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>Decimal</th>\n                <th>Positive Binary</th>\n                <th>-3 in Binary</th>\n                <th>Binary Result</th>\n                <th>Decimal Result</th>\n                <th>Actual Value</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>7</td>\n            <td>0111</td>\n            <td>1100</td>\n            <td>0011</td>\n            <td>3</td>\n            <td>4</tr>\n        <tr>\n            <td>6</td>\n            <td>0110</td>\n            <td>1100</td>\n            <td>0010</td>\n            <td>2</td>\n            <td>3</tr>\n        <tr>\n            <td>5</td>\n            <td>0101</td>\n            <td>1100</td>\n            <td>0001</td>\n            <td>1</td>\n            <td>2</tr>\n        <tr>\n            <td>4</td>\n            <td>0100</td>\n            <td>1100</td>\n            <td>0000</td>\n            <td>0</td>\n            <td>1</tr>\n        <tr>\n            <td>3</td>\n            <td>0011</td>\n            <td>1100</td>\n            <td>1111</td>\n            <td>-0</td>\n            <td>0</tr>\n        <tr>\n            <td>2</td>\n            <td>0010</td>\n            <td>1100</td>\n            <td>1110</td>\n            <td>-1</td>\n            <td>-1</tr>\n        <tr>\n            <td>1</td>\n            <td>0001</td>\n            <td>1100</td>\n            <td>1101</td>\n            <td>-2</td>\n            <td>-2</tr>\n        <tr>\n            <td>0</td>\n            <td>0000</td>\n            <td>1100</td>\n            <td>1100</td>\n            <td>-3</td>\n            <td>-3</td>\n        </tr>\n    </table>\n\n    Each of the positive numbers is off by 1, and there's still that negative 0 in the mix. So, what if we add one to each negative number? That way \n    1111 would become -1 rather than -0, it would correct the error with the negative numbers. Recreating the chart above with this new method, we \n    get the following:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>Decimal</th>\n                <th>Positive Binary</th>\n                <th>-3 in Binary</th>\n                <th>Binary Result</th>\n                <th>Decimal Result</th>\n                <th>Actual Value</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>7</td>\n            <td>0111</td>\n            <td>1101</td>\n            <td>0100</td>\n            <td>3</td>\n            <td>4</tr>\n        <tr>\n            <td>6</td>\n            <td>0110</td>\n            <td>1101</td>\n            <td>0011</td>\n            <td>2</td>\n            <td>3</tr>\n        <tr>\n            <td>5</td>\n            <td>0101</td>\n            <td>1101</td>\n            <td>0010</td>\n            <td>1</td>\n            <td>2</tr>\n        <tr>\n            <td>4</td>\n            <td>0100</td>\n            <td>1101</td>\n            <td>0001</td>\n            <td>0</td>\n            <td>1</tr>\n        <tr>\n            <td>3</td>\n            <td>0011</td>\n            <td>1101</td>\n            <td>0000</td>\n            <td>-0</td>\n            <td>0</tr>\n        <tr>\n            <td>2</td>\n            <td>0010</td>\n            <td>1101</td>\n            <td>1111</td>\n            <td>-1</td>\n            <td>-1</tr>\n        <tr>\n            <td>1</td>\n            <td>0001</td>\n            <td>1101</td>\n            <td>1110</td>\n            <td>-2</td>\n            <td>-2</tr>\n        <tr>\n            <td>0</td>\n            <td>0000</td>\n            <td>1101</td>\n            <td>1101</td>\n            <td>-3</td>\n            <td>-3</td>\n        </tr>\n    </table>\n\n    It now works perfectly! We've just made numbers much easier to add in binary. Now instead of having two separate circuits to add and subtract, \n    all we need to do is to negate each bit in the number being subtracted and add one to it, then we can add the numbers and we have subtraction!<br><br>\n\n    This method of representing binary numbers is also known as the \"2's Complement\" method. It's by far the most common way of representing negative \n    binary numbers due to the reasons presented here.<br><br><br>\n    `;\n\n    document.getElementsByClassName(\"content\")[0].innerHTML = content;\n}\n\nexport {boolean};"},"lineCount":null}},"error":null,"hash":"1d9332a64a34903be9a7ecc741db9bc9","cacheData":{"env":{}}}