{"id":"content/blog/genetic-revision.js","dependencies":[{"name":"/home/ericloux/Desktop/code/portfolio/package.json","includedInParent":true,"mtime":1565309385158}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.geneticRevision = geneticRevision;\n\nfunction geneticRevision() {\n  var content = \"\";\n  content += \"      \\n    <h3>Implementing Genomes</h3>\\n\\n    Now that we have described the scope of the genetic algorithm that we're planning on implementing, we can go ahead and start creating it.<br><br>\\n\\n    It makes sense to create a Genome class in Javascript. That way we can ensure our code is encapsulated in a sensible way. The only data we will need \\n    to store is a string of our 50 genes. We'll provide a number of constructors for this data. The default constructor will create a random number of \\n    genes and store them in the class information. The constructor can replicate reproduction by taking two other Genomes, picking a spot within them, \\n    and copying a portion from one Genome's genes and a portion from the other if two other objects of class Genome are passed to it.<br><br>\\n\\n    Next, we need to write some accessor functions. getNickname() returns the genes as a string of characters. getFullname() returns the genes as a \\n    binary string. Likewise, the gene at a specific position is accessible through the getGeneAt() function. A similar function getFormula() draws the \\n    genes as a series of mathematical symbols. A geneToBinary() and binaryToGene() convert between characters and binary numbers.<br><br>\\n\\n    Lastly, we need to write a way to actually apply the formulas. I've done this by creating a class for most of the larger syntactical elements \\n    described in the previous entry. The NumeralString, DecimalString, Operator, Function, and Term classes each have a constructor and a getGeneClass() \\n    function. The NumeralString and DecimalString classes have functions to easily add more digits to them, and the Operator and Function classes can \\n    each take values and apply return the results of the functions. The Term class can also take a NumeralString and DecimalString and keep their \\n    values.<br><br>\\n\\n    Now, all we have to do is add a method to the Genome class that parses the input and evaluates the formula. It does this by creating a list of the \\n    classes mentioned in the last paragraph. It evaluates the next gene, then determines whether the combination is valid. If it runs into an invalid \\n    combination, then it returns false. Otherwise, it will return the value.<br><br>\\n\\n    After implementing all of this and running it, I realize my first problem. For every gene, there's just under a 50% chance that the combination \\n    will invalidate itself. This means, after 50 genes, there's about a one in 2^50 chance that the gene creates a valid combination. Expressed as a \\n    percentage, that means there is a less than \\n    10^-13 percent that the gene will be valid. Needless to say, in order for this to work, I need to determine a new \\n    method of either encoding genes, or a new way of turning them into a valid phenotype.<br><br>\\n\\n    So, in order to minimize the number of invalid phenotypes, what alternatives do we have? We need a way to make the genes dynamic. Certain genes \\n    be more likely to follow other genes in valid combinations, rather than just hoping that the chain works out. So, instead of 32 gene \\n    characters, we'll reduce the set to 16. I've chosen the letters A through P to represent those genes. We'll also create two modes - a numeral string \\n    mode and an operator mode. <br><br>\\n\\n    In the numeral mode, the first ten characters (A-J) will add the numerals 0 through 9 to the numeral string. The remaining characters are split \\n    into three groups: a decimal group (K and L), a input group (M and N), and a mode group (O and P). The decimal group will add a decimal to the \\n    equation the first time it is found in a portion of a gene that describes a numeral. Each time the input group is called, the number of times \\n    that the numeral will be multiplied by the input term increases. (This will happen once the entire numeral string is described.) Finally, the mode \\n    group will terminate the numeral and switch to the operator mode.<br><br>\\n\\n    In the operator mode, the first eight genes (A-H) will code for operations that operate on the previous term, while the second eight (I-P) will \\n    code for operations that operate on two terms while also switching back to the numeral mode. These codes are described in the following \\n    table:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>Gene</th>\\n                <th>Operator</th>\\n                <th>Gene</th>\\n                <th>Operator</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>A</td>\\n            <td>Negate</td>\\n            <td>I</td>\\n            <td>Exponent</tr>\\n        <tr>\\n            <td>B</td>\\n            <td>Ceiling</td>\\n            <td>J</td>\\n            <td>Subtraction</tr>\\n        <tr>\\n            <td>C</td>\\n            <td>Negate</td>\\n            <td>K</td>\\n            <td>Remainder</tr>\\n        <tr>\\n            <td>D</td>\\n            <td>Increment</td>\\n            <td>L</td>\\n            <td>Subtraction</tr>\\n        <tr>\\n            <td>E</td>\\n            <td>Zero</td>\\n            <td>M</td>\\n            <td>Multiplication</tr>\\n        <tr>\\n            <td>F</td>\\n            <td>Floor</td>\\n            <td>N</td>\\n            <td>Addition</tr>\\n        <tr>\\n            <td>G</td>\\n            <td>Zero</td>\\n            <td>O</td>\\n            <td>Division</tr>\\n        <tr>\\n            <td>H</td>\\n            <td>Decrement</td>\\n            <td>P</td>\\n            <td>Addition</td>\\n        </tr>\\n    </table>\\n\\n    Note that there are a couple of operations that are duplicated. These are common operations, so it makes sense to make them more \\n    likely to happen.<br><br>\\n\\n    With these revised phenotype decoding rules, we've drastically decreased the number of invalid codes. Now, the only way that a genome can be \\n    malformed is if it ends in a two-term operator.<br><br>\\n\\n    With these modifications, we've gone from nearly no chance of a valid phenotype to a fifteen out of sixteen chance that the genotype will create \\n    a mathematical function. From here, all that needs to happen is to reevaluate how to implement this new version of the genome, and then run the \\n    simulation.<br><br><br><br>\\n    \";\n  document.getElementsByClassName(\"content\")[0].innerHTML = content;\n}"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":8,"column":0},"source":"content/blog/genetic-revision.js","original":{"line":1,"column":0}},{"name":"geneticRevision","generated":{"line":8,"column":9},"source":"content/blog/genetic-revision.js","original":{"line":1,"column":9}},{"generated":{"line":8,"column":24},"source":"content/blog/genetic-revision.js","original":{"line":1,"column":0}},{"generated":{"line":8,"column":27},"source":"content/blog/genetic-revision.js","original":{"line":1,"column":27}},{"generated":{"line":9,"column":0},"source":"content/blog/genetic-revision.js","original":{"line":2,"column":4}},{"name":"content","generated":{"line":9,"column":6},"source":"content/blog/genetic-revision.js","original":{"line":2,"column":8}},{"generated":{"line":9,"column":13},"source":"content/blog/genetic-revision.js","original":{"line":2,"column":15}},{"generated":{"line":9,"column":16},"source":"content/blog/genetic-revision.js","original":{"line":2,"column":18}},{"generated":{"line":9,"column":18},"source":"content/blog/genetic-revision.js","original":{"line":2,"column":4}},{"name":"content","generated":{"line":10,"column":0},"source":"content/blog/genetic-revision.js","original":{"line":4,"column":4}},{"name":"content","generated":{"line":10,"column":2},"source":"content/blog/genetic-revision.js","original":{"line":4,"column":4}},{"generated":{"line":10,"column":9},"source":"content/blog/genetic-revision.js","original":{"line":4,"column":11}},{"generated":{"line":10,"column":6291},"source":"content/blog/genetic-revision.js","original":{"line":4,"column":4}},{"name":"document","generated":{"line":11,"column":0},"source":"content/blog/genetic-revision.js","original":{"line":112,"column":4}},{"name":"document","generated":{"line":11,"column":2},"source":"content/blog/genetic-revision.js","original":{"line":112,"column":4}},{"generated":{"line":11,"column":10},"source":"content/blog/genetic-revision.js","original":{"line":112,"column":12}},{"name":"getElementsByClassName","generated":{"line":11,"column":11},"source":"content/blog/genetic-revision.js","original":{"line":112,"column":13}},{"generated":{"line":11,"column":33},"source":"content/blog/genetic-revision.js","original":{"line":112,"column":4}},{"generated":{"line":11,"column":34},"source":"content/blog/genetic-revision.js","original":{"line":112,"column":36}},{"generated":{"line":11,"column":43},"source":"content/blog/genetic-revision.js","original":{"line":112,"column":4}},{"generated":{"line":11,"column":45},"source":"content/blog/genetic-revision.js","original":{"line":112,"column":47}},{"generated":{"line":11,"column":46},"source":"content/blog/genetic-revision.js","original":{"line":112,"column":4}},{"name":"innerHTML","generated":{"line":11,"column":48},"source":"content/blog/genetic-revision.js","original":{"line":112,"column":50}},{"generated":{"line":11,"column":57},"source":"content/blog/genetic-revision.js","original":{"line":112,"column":4}},{"name":"content","generated":{"line":11,"column":60},"source":"content/blog/genetic-revision.js","original":{"line":112,"column":62}},{"generated":{"line":11,"column":67},"source":"content/blog/genetic-revision.js","original":{"line":112,"column":4}},{"generated":{"line":12,"column":0},"source":"content/blog/genetic-revision.js","original":{"line":113,"column":1}}],"sources":{"content/blog/genetic-revision.js":"function geneticRevision() {\n    let content = \"\";\n\n    content += `      \n    <h3>Implementing Genomes</h3>\n\n    Now that we have described the scope of the genetic algorithm that we're planning on implementing, we can go ahead and start creating it.<br><br>\n\n    It makes sense to create a Genome class in Javascript. That way we can ensure our code is encapsulated in a sensible way. The only data we will need \n    to store is a string of our 50 genes. We'll provide a number of constructors for this data. The default constructor will create a random number of \n    genes and store them in the class information. The constructor can replicate reproduction by taking two other Genomes, picking a spot within them, \n    and copying a portion from one Genome's genes and a portion from the other if two other objects of class Genome are passed to it.<br><br>\n\n    Next, we need to write some accessor functions. getNickname() returns the genes as a string of characters. getFullname() returns the genes as a \n    binary string. Likewise, the gene at a specific position is accessible through the getGeneAt() function. A similar function getFormula() draws the \n    genes as a series of mathematical symbols. A geneToBinary() and binaryToGene() convert between characters and binary numbers.<br><br>\n\n    Lastly, we need to write a way to actually apply the formulas. I've done this by creating a class for most of the larger syntactical elements \n    described in the previous entry. The NumeralString, DecimalString, Operator, Function, and Term classes each have a constructor and a getGeneClass() \n    function. The NumeralString and DecimalString classes have functions to easily add more digits to them, and the Operator and Function classes can \n    each take values and apply return the results of the functions. The Term class can also take a NumeralString and DecimalString and keep their \n    values.<br><br>\n\n    Now, all we have to do is add a method to the Genome class that parses the input and evaluates the formula. It does this by creating a list of the \n    classes mentioned in the last paragraph. It evaluates the next gene, then determines whether the combination is valid. If it runs into an invalid \n    combination, then it returns false. Otherwise, it will return the value.<br><br>\n\n    After implementing all of this and running it, I realize my first problem. For every gene, there's just under a 50% chance that the combination \n    will invalidate itself. This means, after 50 genes, there's about a one in 2^50 chance that the gene creates a valid combination. Expressed as a \n    percentage, that means there is a less than \n    10^-13 percent that the gene will be valid. Needless to say, in order for this to work, I need to determine a new \n    method of either encoding genes, or a new way of turning them into a valid phenotype.<br><br>\n\n    So, in order to minimize the number of invalid phenotypes, what alternatives do we have? We need a way to make the genes dynamic. Certain genes \n    be more likely to follow other genes in valid combinations, rather than just hoping that the chain works out. So, instead of 32 gene \n    characters, we'll reduce the set to 16. I've chosen the letters A through P to represent those genes. We'll also create two modes - a numeral string \n    mode and an operator mode. <br><br>\n\n    In the numeral mode, the first ten characters (A-J) will add the numerals 0 through 9 to the numeral string. The remaining characters are split \n    into three groups: a decimal group (K and L), a input group (M and N), and a mode group (O and P). The decimal group will add a decimal to the \n    equation the first time it is found in a portion of a gene that describes a numeral. Each time the input group is called, the number of times \n    that the numeral will be multiplied by the input term increases. (This will happen once the entire numeral string is described.) Finally, the mode \n    group will terminate the numeral and switch to the operator mode.<br><br>\n\n    In the operator mode, the first eight genes (A-H) will code for operations that operate on the previous term, while the second eight (I-P) will \n    code for operations that operate on two terms while also switching back to the numeral mode. These codes are described in the following \n    table:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>Gene</th>\n                <th>Operator</th>\n                <th>Gene</th>\n                <th>Operator</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>A</td>\n            <td>Negate</td>\n            <td>I</td>\n            <td>Exponent</tr>\n        <tr>\n            <td>B</td>\n            <td>Ceiling</td>\n            <td>J</td>\n            <td>Subtraction</tr>\n        <tr>\n            <td>C</td>\n            <td>Negate</td>\n            <td>K</td>\n            <td>Remainder</tr>\n        <tr>\n            <td>D</td>\n            <td>Increment</td>\n            <td>L</td>\n            <td>Subtraction</tr>\n        <tr>\n            <td>E</td>\n            <td>Zero</td>\n            <td>M</td>\n            <td>Multiplication</tr>\n        <tr>\n            <td>F</td>\n            <td>Floor</td>\n            <td>N</td>\n            <td>Addition</tr>\n        <tr>\n            <td>G</td>\n            <td>Zero</td>\n            <td>O</td>\n            <td>Division</tr>\n        <tr>\n            <td>H</td>\n            <td>Decrement</td>\n            <td>P</td>\n            <td>Addition</td>\n        </tr>\n    </table>\n\n    Note that there are a couple of operations that are duplicated. These are common operations, so it makes sense to make them more \n    likely to happen.<br><br>\n\n    With these revised phenotype decoding rules, we've drastically decreased the number of invalid codes. Now, the only way that a genome can be \n    malformed is if it ends in a two-term operator.<br><br>\n\n    With these modifications, we've gone from nearly no chance of a valid phenotype to a fifteen out of sixteen chance that the genotype will create \n    a mathematical function. From here, all that needs to happen is to reevaluate how to implement this new version of the genome, and then run the \n    simulation.<br><br><br><br>\n    `;\n\n    document.getElementsByClassName(\"content\")[0].innerHTML = content;\n}\n\nexport {geneticRevision};"},"lineCount":null}},"error":null,"hash":"7ade1a19e8b8a4cef9d4394eaf338821","cacheData":{"env":{}}}