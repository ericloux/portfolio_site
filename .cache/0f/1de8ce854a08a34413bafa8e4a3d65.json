{"id":"content/blog/boolean.js","dependencies":[],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.boolean = boolean;\n\nfunction boolean() {\n  var content = \"\";\n  content += \"\\n    <h3>\\n    Boolean Functions\\n    </h3>\\n\\n    Previously, we had examined how switches and resistors could turn a basic circuit into a logic gate. We also built logic gates that represented \\n    logical not, and, and nand. Naturally, at this level, there is not much practical application. However, by continuing to build on the previous \\n    concepts, we can continue to add functionality, eventually building chips that can solve more complex problems.<br><br>\\n    \\n    At this point, we have built a few gates. The not gate took one input and output the opposite: if the input was on, the output was off, and \\n    vice-versa. The and gate outputs on only if both of the input gates are true. Likewise, the nand gate is the opposite, outputting off only if \\n    both of the inputs are true. In addition to these gates, how many more exist, and can we build them?<br><br>\\n    \\n    The number of unique gates that can be created is dependent on the number of inputs. For example, a one-input gate has two states that can feed \\n    into it, on or off. For those two states, there are four sets out outputs that can result: (on, on), (on, off), (off, on), and (off, off). If we \\n    think of the possible input states as (on, off), then we can chart out each of the possible relationships that can result from this input \\n    state:<br><br>\\n    \\n    <table>\\n        <thead>\\n            <tr>\\n                <th>Input</th>\\t\\n                <th>Output 1</th>\\t\\n                <th>Output 2</th>\\t\\n                <th>Output 3</th>\\t\\n                <th>Output 4</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\n        </tr>\\n        <tr>\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\n        </tr>\\n    </table><br>\\n    \\n    If you compare the input to Output 3, then you see it's the same as the not gate we previously built. Looking at the other gates built here are \\n    also not particularly exciting. Output 1 is always on, independent of the input. Similarly, Output 4 is always off. The implementation of them \\n    is simple - the former simply represents any closed circuit, and the other, any open circuit. Lastly, Output 2 is exactly the same as the input. \\n    Most of the gates, excluding not, are not particularly userful.<br><br>\\n    \\n    Now, what happens if we have two inputs? This is where things get interesting, but also more complex. Instead of having the input only be on or \\n    off as with a one-input gate, they can now be any of the sets (on, on), (on, off), (off, on), or (off, off). Each of these pairs of inputs can \\n    have two choices for output. This means that there are 2^4 different potential output sets. Compare this to the single-input gate, where there \\n    are 2^2 choices. With no inputs, the output can either be on or off, showing 2^1. Therefore, with x input gates, there are 2^(2^x-1) possible \\n    unique gates that can be created. That means with three inputs, there are 256 different functions. Examining each of those is unnecessary, but \\n    there are a few important three-input logic gates that we will consider at a future point.<br><br>\\n    \\n    We can create tables showing the potential outputs given the inputs. Such a table is called a truth table. We have done this above for all single \\n    input gate combinations, but we can do this for two-input gates as well. Creating a table with all sixteen is a bit extreme, so here are the gates \\n    we have already explored (including the two input versions of the single-input gates). Note that we are calling each output column by a name that \\n    describes its function, rather than an arbitrary number:<br><br>\\n    \\n    <table>\\n        <thead>\\n            <tr>\\n                <th>Input 1</th>\\t\\n                <th>Input 2</th>\\t\\n                <th>Always</th>\\t\\n                <th>Never</th>\\t\\n                <th>Not 1</th>\\t\\n                <th>Not 2</th>\\t\\n                <th>And</th>\\t\\n                <th>Nand</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\n        </tr>\\n        <tr>\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\n        </tr>\\n        <tr>\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\n        </tr>\\n        <tr>\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\n        </tr>\\n    </table\\n    \\n    Note that there are two functions for not - one that returns the opposite of input 1 and the other with input 2. Of course, we also have the \\n    gates that always return true and false (which are named Always and Never respectively), and the And and Nand gates we had previously examined. \\n    Given that there are sixteen in total, what are the others? Two are outputs that match each of the inputs - that is, if Input 1 is on, then the \\n    output will be on regardless of Input 2. A similar gate can exist that matches Input 2 and ignores Input 1. This brings the total to 8, but what \\n    about the others?<br><br>\\n    \\n    Here is a truth table showing the remaining eight gates. Here is a truth table showing their values and names:<br><br>\\n    \\n    <table>\\n        <thead>\\n            <tr>\\n                <th>Input 1</th>\\t\\n                <th>Input 2</th>\\t\\n                <th>Only 1</th>\\t\\n                <th>Only 2</th>\\t\\n                <th>Xor</th>\\t\\n                <th>Or</th>\\t\\n                <th>Nor</th>\\t\\n                <th>Xnor</th>\\n                <th>1 or not 2</th>\\n                <th>2 or not 1</th>\\n            </tr>\\n        </thead>\\t\\n        <tr>\\t\\n            <td>on</td>\\t\\n            <td>on</td>\\t\\n            <td>off</td>\\t\\n            <td>off</td>\\t\\n            <td>off</td>\\t\\n            <td>on</td>\\t\\n            <td>off</td>\\t\\n            <td>on</td>\\t\\n            <td>on</td>\\t\\n            <td>on</td>\\n        </tr>\\n        <tr>\\n            <td>on</td>\\t\\n            <td>off</td>\\t\\n            <td>on</td>\\t\\n            <td>off</td>\\t\\n            <td>on</td>\\t\\n            <td>on</td>\\t\\n            <td>off</td>\\t\\n            <td>off</td>\\t\\n            <td>on</td>\\t\\n            <td>off</td>\\n        </tr>\\n        <tr>\\t\\n            <td>off</td>\\t\\n            <td>on</td>\\t\\n            <td>off</td>\\t\\n            <td>on</td>\\t\\n            <td>on</td>\\t\\n            <td>on</td>\\t\\n            <td>off</td>\\t\\n            <td>off</td>\\t\\n            <td>off</td>\\t\\n            <td>on</td>\\n        </tr>\\n        <tr>\\n            <td>off</td>\\t\\n            <td>off</td>\\t\\n            <td>off</td>\\t\\n            <td>off</td>\\t\\n            <td>off</td>\\t\\n            <td>off</td>\\t\\n            <td>on</td>\\t\\n            <td>on</td>\\t\\n            <td>on</td>\\t\\n            <td>on</td>\\n        <tr>\\n    </table>\\t\\n    \\n    Now that we have the full set, we can begin examining how to build them. Since we have already shown how to use the gates in the first set, we \\n    can chain those together to create even more gates. We will see examples as we construct this second set, but there are a couple of ideas that \\n    may not be intuitive that allow for construction of these more complex gates.<br><br>\\n    \\n    First, the output of one gate can be fed into the input of another. For example, if you put two inputs through an And gate, and then put the \\n    output of the And gate through a Not gate, then you end up with a Nand gate. Of course, the way we described to build a Nand gate previously \\n    is more straightforward, but it illustrates the concept. Second, the input for one gate can split and simultaneously fed into another gate. \\n    If we take one input and feed it into both inputs for a Nand gate, for example, then we end up with a Not gate. Again, the earlier method is \\n    easier. Note also that both inputs don't necessarily need to feed into the same gate.<br><br>\\n    \\n    With that, let's examine each of the gates and see how we can construct them.<br><br>\\n    \\n    If we feed one of the inputs into a Not gate, then feed the result of that input into an And gate with the other input, then the result is an \\n    Only gate. To demonstrate that, here is another truth table that shows the values at each step of the way:<br><br>\\n    \\n    <table>\\n        <thead>\\n            <tr>\\n                <th>Input 1</th>\\t\\n                <th>Input 2</th>\\t\\n                <th>Not 1</th>\\t\\n                <th>2 And Not 1</th>\\t\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>on</td>\\t\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\n        </tr>\\n        <tr>\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\n        </tr>\\n        <tr>\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\n        </tr>\\n        <tr>\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\n        </tr>\\n    </table><br>\\n    \\n    Note that this is identical to the Only 2 gate described above. In fact, another name for this gate is the And Not gate. Also, even though \\n    there are two inputs and one output, we have four columns in our truth table. This is so we can see the effect of our operations at an \\n    intermediate point - in this case, after Not has been applied to Input 1. Truth tables are a great debugging tool. If you write out the inputs \\n    and the expected outputs, then perform intermediate calculations, then you can start to narrow down the operations needed to end at a specific \\n    output. This works for numbers as well, although in that setting, it is called a function table rather than a truth table.<br><br>\\n    \\n    Of course, if we take our Only logic gate and flip the inputs, running Input 2 through the Not gate before combining it with Input 1 in an And \\n    gate, then we get the other version of the Only gate, which is on only if Input 1 is on. On top of that, if we run the output of one of the Only \\n    gates through a Not gate, then we get the 1 Or Not 2 and 2 Or Not 1 gates, depending on which version of the Only gate we started with. As you \\n    can see, adding these gates together can quickly provide a variety of new functions quickly.<br><br>\\n    \\n    Having implemented half the gates, the only four remaining all appear very similar: Or, Nor, Xor, and Xnor. \\\"Or\\\" means exactly what you think \\n    it does - if Input 1 or Input 2 is on, then the output is on as well. If both are on, then it is true as well. Each of the other three gates \\n    have some combination of N and X in front of the or. The N stands Not, much as it did with Nand. Of course, \\\"nor\\\" is also a word in English \\n    that means exactly that - it is only on if neither input is on. The X means exclusive. In the case of Xor, it will be on only if exactly one \\n    of the inputs is on. With Xnor, it will be true only if the inputs are equal - that is, they are both on, or both off. With this understanding, \\n    we can move forward with seeing how they might be implemented.<br><br>\\n    \\n    To make the Only gates, we flipped one of the inputs with a Not gate, then ran both through an And gate. So what happens if we invert them both \\n    before running them through the And gate? We can make a truth table to easily see the result:<br><br>\\n    \\n    <table>\\n        <thead>\\n            <tr>\\n                <th>Input 1</th>\\t\\n                <th>Input 2</th>\\t\\n                <th>Not 1</th>\\t\\n                <th>Not 2</th>\\t\\n                <th>Not 1 And Not 2</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\n        </tr>\\n        <tr>\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\n        </tr>\\n        <tr>\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\n        </tr>\\n        <tr>\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\n        </tr>\\n    </table><br>\\n    \\n    Looking at the table above, we've just made our Nor gate! It's the same as taking Not 1 And Not 2. Of course, 1 Nor 2 is a much simpler way of \\n    expressing that relationship. From here, if we put the output of our Nor gate through another Not gate, then the relationship we get is the Or \\n    gate. (Remember, the N stands for \\\"not,\\\" so taking Not Nor is the same as taking Not Not Or, which is another way to say just Or.<br><br>\\n    \\n    Now, the only two gates that we have to represent are Xor and Xnor. These gates are also opposites, as Xor is on only if the inputs do not match, \\n    and Xnor only if they do match. So, if we can create one, we can run it through a Not gate and get the other missing gate. (And, technically, \\n    we can make each of these gates in other ways with the gates that we have already created. If we look at the language we use to describe \\n    the Xnor gate in English, we can get a hint as to how we might create it from our gates. Remember, a Xnor gate is on if the inputs are both \\n    on. That is, if Input 1 and Input 2 are on, or if Input 1 is off and Input 2 is off. Let's create a truth table that shows each of these \\n    relationships:<br><br>\\n    \\n    <table>\\n        <thead>\\n            <tr>\\n                <th>Input 1</th>\\t\\n                <th>Input 2</th>\\t\\n                <th>And</th>\\t\\n                <th>Not 1</th>\\t\\n                <th>Not 2</th>\\t\\n                <th>Not 1 And Not 2</th>\\t\\n                <th>(1 And 2) Or (Not 1 And Not 2)</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\n        </tr>\\n        <tr>\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\n        </tr>\\n        <tr>\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\n        </tr>\\n        <tr>\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>off</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\t\\t\\n            <td>on</td>\\n        </tr>\\n    </table><br>\\n    \\n    Voila, the Xnor gate! As said before, putting this through a Not gate will give us the Xor gate, which means that now we can represent each of \\n    these 16 two-input gates with real hardware. While not particularly useful on their own, if we continue to build on these gates, we'll be able \\n    to create some chips that we can put to work for us!<br><br>\\n    \";\n  document.getElementsByClassName(\"content\")[0].innerHTML = content;\n}"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":8,"column":0},"source":"content/blog/boolean.js","original":{"line":1,"column":0}},{"name":"boolean","generated":{"line":8,"column":9},"source":"content/blog/boolean.js","original":{"line":1,"column":9}},{"generated":{"line":8,"column":16},"source":"content/blog/boolean.js","original":{"line":1,"column":0}},{"generated":{"line":8,"column":19},"source":"content/blog/boolean.js","original":{"line":1,"column":19}},{"generated":{"line":9,"column":0},"source":"content/blog/boolean.js","original":{"line":2,"column":4}},{"name":"content","generated":{"line":9,"column":6},"source":"content/blog/boolean.js","original":{"line":2,"column":8}},{"generated":{"line":9,"column":13},"source":"content/blog/boolean.js","original":{"line":2,"column":15}},{"generated":{"line":9,"column":16},"source":"content/blog/boolean.js","original":{"line":2,"column":18}},{"generated":{"line":9,"column":18},"source":"content/blog/boolean.js","original":{"line":2,"column":4}},{"name":"content","generated":{"line":10,"column":0},"source":"content/blog/boolean.js","original":{"line":4,"column":4}},{"name":"content","generated":{"line":10,"column":2},"source":"content/blog/boolean.js","original":{"line":4,"column":4}},{"generated":{"line":10,"column":9},"source":"content/blog/boolean.js","original":{"line":4,"column":11}},{"generated":{"line":10,"column":16317},"source":"content/blog/boolean.js","original":{"line":4,"column":4}},{"name":"document","generated":{"line":11,"column":0},"source":"content/blog/boolean.js","original":{"line":370,"column":4}},{"name":"document","generated":{"line":11,"column":2},"source":"content/blog/boolean.js","original":{"line":370,"column":4}},{"generated":{"line":11,"column":10},"source":"content/blog/boolean.js","original":{"line":370,"column":12}},{"name":"getElementsByClassName","generated":{"line":11,"column":11},"source":"content/blog/boolean.js","original":{"line":370,"column":13}},{"generated":{"line":11,"column":33},"source":"content/blog/boolean.js","original":{"line":370,"column":4}},{"generated":{"line":11,"column":34},"source":"content/blog/boolean.js","original":{"line":370,"column":36}},{"generated":{"line":11,"column":43},"source":"content/blog/boolean.js","original":{"line":370,"column":4}},{"generated":{"line":11,"column":45},"source":"content/blog/boolean.js","original":{"line":370,"column":47}},{"generated":{"line":11,"column":46},"source":"content/blog/boolean.js","original":{"line":370,"column":4}},{"name":"innerHTML","generated":{"line":11,"column":48},"source":"content/blog/boolean.js","original":{"line":370,"column":50}},{"generated":{"line":11,"column":57},"source":"content/blog/boolean.js","original":{"line":370,"column":4}},{"name":"content","generated":{"line":11,"column":60},"source":"content/blog/boolean.js","original":{"line":370,"column":62}},{"generated":{"line":11,"column":67},"source":"content/blog/boolean.js","original":{"line":370,"column":4}},{"generated":{"line":12,"column":0},"source":"content/blog/boolean.js","original":{"line":371,"column":1}}],"sources":{"content/blog/boolean.js":"function boolean() {\n    let content = \"\";\n\n    content += `\n    <h3>\n    Boolean Functions\n    </h3>\n\n    Previously, we had examined how switches and resistors could turn a basic circuit into a logic gate. We also built logic gates that represented \n    logical not, and, and nand. Naturally, at this level, there is not much practical application. However, by continuing to build on the previous \n    concepts, we can continue to add functionality, eventually building chips that can solve more complex problems.<br><br>\n    \n    At this point, we have built a few gates. The not gate took one input and output the opposite: if the input was on, the output was off, and \n    vice-versa. The and gate outputs on only if both of the input gates are true. Likewise, the nand gate is the opposite, outputting off only if \n    both of the inputs are true. In addition to these gates, how many more exist, and can we build them?<br><br>\n    \n    The number of unique gates that can be created is dependent on the number of inputs. For example, a one-input gate has two states that can feed \n    into it, on or off. For those two states, there are four sets out outputs that can result: (on, on), (on, off), (off, on), and (off, off). If we \n    think of the possible input states as (on, off), then we can chart out each of the possible relationships that can result from this input \n    state:<br><br>\n    \n    <table>\n        <thead>\n            <tr>\n                <th>Input</th>\t\n                <th>Output 1</th>\t\n                <th>Output 2</th>\t\n                <th>Output 3</th>\t\n                <th>Output 4</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>on</td>\t\t\n            <td>on</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\n        </tr>\n        <tr>\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\n        </tr>\n    </table><br>\n    \n    If you compare the input to Output 3, then you see it's the same as the not gate we previously built. Looking at the other gates built here are \n    also not particularly exciting. Output 1 is always on, independent of the input. Similarly, Output 4 is always off. The implementation of them \n    is simple - the former simply represents any closed circuit, and the other, any open circuit. Lastly, Output 2 is exactly the same as the input. \n    Most of the gates, excluding not, are not particularly userful.<br><br>\n    \n    Now, what happens if we have two inputs? This is where things get interesting, but also more complex. Instead of having the input only be on or \n    off as with a one-input gate, they can now be any of the sets (on, on), (on, off), (off, on), or (off, off). Each of these pairs of inputs can \n    have two choices for output. This means that there are 2^4 different potential output sets. Compare this to the single-input gate, where there \n    are 2^2 choices. With no inputs, the output can either be on or off, showing 2^1. Therefore, with x input gates, there are 2^(2^x-1) possible \n    unique gates that can be created. That means with three inputs, there are 256 different functions. Examining each of those is unnecessary, but \n    there are a few important three-input logic gates that we will consider at a future point.<br><br>\n    \n    We can create tables showing the potential outputs given the inputs. Such a table is called a truth table. We have done this above for all single \n    input gate combinations, but we can do this for two-input gates as well. Creating a table with all sixteen is a bit extreme, so here are the gates \n    we have already explored (including the two input versions of the single-input gates). Note that we are calling each output column by a name that \n    describes its function, rather than an arbitrary number:<br><br>\n    \n    <table>\n        <thead>\n            <tr>\n                <th>Input 1</th>\t\n                <th>Input 2</th>\t\n                <th>Always</th>\t\n                <th>Never</th>\t\n                <th>Not 1</th>\t\n                <th>Not 2</th>\t\n                <th>And</th>\t\n                <th>Nand</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>on</td>\t\t\n            <td>on</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\n        </tr>\n        <tr>\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\n        </tr>\n        <tr>\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\n        </tr>\n        <tr>\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\n        </tr>\n    </table\n    \n    Note that there are two functions for not - one that returns the opposite of input 1 and the other with input 2. Of course, we also have the \n    gates that always return true and false (which are named Always and Never respectively), and the And and Nand gates we had previously examined. \n    Given that there are sixteen in total, what are the others? Two are outputs that match each of the inputs - that is, if Input 1 is on, then the \n    output will be on regardless of Input 2. A similar gate can exist that matches Input 2 and ignores Input 1. This brings the total to 8, but what \n    about the others?<br><br>\n    \n    Here is a truth table showing the remaining eight gates. Here is a truth table showing their values and names:<br><br>\n    \n    <table>\n        <thead>\n            <tr>\n                <th>Input 1</th>\t\n                <th>Input 2</th>\t\n                <th>Only 1</th>\t\n                <th>Only 2</th>\t\n                <th>Xor</th>\t\n                <th>Or</th>\t\n                <th>Nor</th>\t\n                <th>Xnor</th>\n                <th>1 or not 2</th>\n                <th>2 or not 1</th>\n            </tr>\n        </thead>\t\n        <tr>\t\n            <td>on</td>\t\n            <td>on</td>\t\n            <td>off</td>\t\n            <td>off</td>\t\n            <td>off</td>\t\n            <td>on</td>\t\n            <td>off</td>\t\n            <td>on</td>\t\n            <td>on</td>\t\n            <td>on</td>\n        </tr>\n        <tr>\n            <td>on</td>\t\n            <td>off</td>\t\n            <td>on</td>\t\n            <td>off</td>\t\n            <td>on</td>\t\n            <td>on</td>\t\n            <td>off</td>\t\n            <td>off</td>\t\n            <td>on</td>\t\n            <td>off</td>\n        </tr>\n        <tr>\t\n            <td>off</td>\t\n            <td>on</td>\t\n            <td>off</td>\t\n            <td>on</td>\t\n            <td>on</td>\t\n            <td>on</td>\t\n            <td>off</td>\t\n            <td>off</td>\t\n            <td>off</td>\t\n            <td>on</td>\n        </tr>\n        <tr>\n            <td>off</td>\t\n            <td>off</td>\t\n            <td>off</td>\t\n            <td>off</td>\t\n            <td>off</td>\t\n            <td>off</td>\t\n            <td>on</td>\t\n            <td>on</td>\t\n            <td>on</td>\t\n            <td>on</td>\n        <tr>\n    </table>\t\n    \n    Now that we have the full set, we can begin examining how to build them. Since we have already shown how to use the gates in the first set, we \n    can chain those together to create even more gates. We will see examples as we construct this second set, but there are a couple of ideas that \n    may not be intuitive that allow for construction of these more complex gates.<br><br>\n    \n    First, the output of one gate can be fed into the input of another. For example, if you put two inputs through an And gate, and then put the \n    output of the And gate through a Not gate, then you end up with a Nand gate. Of course, the way we described to build a Nand gate previously \n    is more straightforward, but it illustrates the concept. Second, the input for one gate can split and simultaneously fed into another gate. \n    If we take one input and feed it into both inputs for a Nand gate, for example, then we end up with a Not gate. Again, the earlier method is \n    easier. Note also that both inputs don't necessarily need to feed into the same gate.<br><br>\n    \n    With that, let's examine each of the gates and see how we can construct them.<br><br>\n    \n    If we feed one of the inputs into a Not gate, then feed the result of that input into an And gate with the other input, then the result is an \n    Only gate. To demonstrate that, here is another truth table that shows the values at each step of the way:<br><br>\n    \n    <table>\n        <thead>\n            <tr>\n                <th>Input 1</th>\t\n                <th>Input 2</th>\t\n                <th>Not 1</th>\t\n                <th>2 And Not 1</th>\t\n            </tr>\n        </thead>\n        <tr>\n            <td>on</td>\t\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\n        </tr>\n        <tr>\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\n        </tr>\n        <tr>\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>on</td>\t\t\n            <td>on</td>\n        </tr>\n        <tr>\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\n        </tr>\n    </table><br>\n    \n    Note that this is identical to the Only 2 gate described above. In fact, another name for this gate is the And Not gate. Also, even though \n    there are two inputs and one output, we have four columns in our truth table. This is so we can see the effect of our operations at an \n    intermediate point - in this case, after Not has been applied to Input 1. Truth tables are a great debugging tool. If you write out the inputs \n    and the expected outputs, then perform intermediate calculations, then you can start to narrow down the operations needed to end at a specific \n    output. This works for numbers as well, although in that setting, it is called a function table rather than a truth table.<br><br>\n    \n    Of course, if we take our Only logic gate and flip the inputs, running Input 2 through the Not gate before combining it with Input 1 in an And \n    gate, then we get the other version of the Only gate, which is on only if Input 1 is on. On top of that, if we run the output of one of the Only \n    gates through a Not gate, then we get the 1 Or Not 2 and 2 Or Not 1 gates, depending on which version of the Only gate we started with. As you \n    can see, adding these gates together can quickly provide a variety of new functions quickly.<br><br>\n    \n    Having implemented half the gates, the only four remaining all appear very similar: Or, Nor, Xor, and Xnor. \"Or\" means exactly what you think \n    it does - if Input 1 or Input 2 is on, then the output is on as well. If both are on, then it is true as well. Each of the other three gates \n    have some combination of N and X in front of the or. The N stands Not, much as it did with Nand. Of course, \"nor\" is also a word in English \n    that means exactly that - it is only on if neither input is on. The X means exclusive. In the case of Xor, it will be on only if exactly one \n    of the inputs is on. With Xnor, it will be true only if the inputs are equal - that is, they are both on, or both off. With this understanding, \n    we can move forward with seeing how they might be implemented.<br><br>\n    \n    To make the Only gates, we flipped one of the inputs with a Not gate, then ran both through an And gate. So what happens if we invert them both \n    before running them through the And gate? We can make a truth table to easily see the result:<br><br>\n    \n    <table>\n        <thead>\n            <tr>\n                <th>Input 1</th>\t\n                <th>Input 2</th>\t\n                <th>Not 1</th>\t\n                <th>Not 2</th>\t\n                <th>Not 1 And Not 2</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>on</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\n        </tr>\n        <tr>\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\n        </tr>\n        <tr>\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\n        </tr>\n        <tr>\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>on</td>\t\t\n            <td>on</td>\n        </tr>\n    </table><br>\n    \n    Looking at the table above, we've just made our Nor gate! It's the same as taking Not 1 And Not 2. Of course, 1 Nor 2 is a much simpler way of \n    expressing that relationship. From here, if we put the output of our Nor gate through another Not gate, then the relationship we get is the Or \n    gate. (Remember, the N stands for \"not,\" so taking Not Nor is the same as taking Not Not Or, which is another way to say just Or.<br><br>\n    \n    Now, the only two gates that we have to represent are Xor and Xnor. These gates are also opposites, as Xor is on only if the inputs do not match, \n    and Xnor only if they do match. So, if we can create one, we can run it through a Not gate and get the other missing gate. (And, technically, \n    we can make each of these gates in other ways with the gates that we have already created. If we look at the language we use to describe \n    the Xnor gate in English, we can get a hint as to how we might create it from our gates. Remember, a Xnor gate is on if the inputs are both \n    on. That is, if Input 1 and Input 2 are on, or if Input 1 is off and Input 2 is off. Let's create a truth table that shows each of these \n    relationships:<br><br>\n    \n    <table>\n        <thead>\n            <tr>\n                <th>Input 1</th>\t\n                <th>Input 2</th>\t\n                <th>And</th>\t\n                <th>Not 1</th>\t\n                <th>Not 2</th>\t\n                <th>Not 1 And Not 2</th>\t\n                <th>(1 And 2) Or (Not 1 And Not 2)</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>on</td>\t\t\n            <td>on</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\n        </tr>\n        <tr>\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\n        </tr>\n        <tr>\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\n        </tr>\n        <tr>\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>off</td>\t\t\n            <td>on</td>\t\t\n            <td>on</td>\t\t\n            <td>on</td>\t\t\n            <td>on</td>\n        </tr>\n    </table><br>\n    \n    Voila, the Xnor gate! As said before, putting this through a Not gate will give us the Xor gate, which means that now we can represent each of \n    these 16 two-input gates with real hardware. While not particularly useful on their own, if we continue to build on these gates, we'll be able \n    to create some chips that we can put to work for us!<br><br>\n    `;\n\n    document.getElementsByClassName(\"content\")[0].innerHTML = content;\n}\n\nexport {boolean};"},"lineCount":null}},"error":null,"hash":"9117f79198a4fb51b407174960eff136","cacheData":{"env":{}}}