{"id":"content/blog/fitness.js","dependencies":[{"name":"/home/ericloux/Desktop/code/portfolio/package.json","includedInParent":true,"mtime":1565309385158}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fitness = fitness;\n\nfunction fitness() {\n  var content = \"\";\n  content += \"   \\n    <h3>\\n        The Problem to Solve\\n    </h3>\\n\\n    Now that I've given an overview of what a genetic algorithm is, the next question is what problem should we solve?<br><br>\\n\\n    Finding an equation that describes a curve that passes through a set of points can be a problem that is either trivial to solve or nearly \\n    impossible unless you're an experienced mathematician. Choosing those points based on a method that was not determined mathematically can \\n    make it difficult if not impossible to find an equation that fits the points. However, with a genetic algorithm, finding such an equation \\n    would be (arguably) much easier.<br><br>\\n\\n    So, what data am I choosing for this example? I'm picking the following sets of (x,y) points:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>x</th>\\n                <th>y</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <td>1</td>\\n            <td>8</tr>\\n        <tr>\\n            <td>2</td>\\n            <td>5</tr>\\n        <tr>\\n            <td>3</td>\\n            <td>12</tr>\\n        <tr>\\n            <td>4</td>\\n            <td>12</tr>\\n        <tr>\\n            <td>5</td>\\n            <td>15</tr>\\n        <tr>\\n            <td>6</td>\\n            <td>23</tr>\\n        <tr>\\n            <td>7</td>\\n            <td>15</tr>\\n        <tr>\\n            <td>8</td>\\n            <td>18</tr>\\n        <tr>\\n            <td>9</td>\\n            <td>12</tr>\\n        <tr>\\n            <td>10</td>\\n            <td>4</td>\\n        </tr>\\n    </table>\\n\\n    This may seem like a random set of numbers, but if you substitute each number for its associated letter in the alphabet, then you get one \\n    of the most famous phrases in computer science: \\\"HELLOWORLD.\\\"<br><br>\\n\\n    To start implementing the algorithm, we need to determine the genotype and phenotype. This will involve a mathematical function, so we'll need \\n    a way to represent a function in a way that lends itself to mutation. From there, we'll apply the formula to the numbers 1 through 10 and see \\n    how well they match the given set of points. We'll also need a way to quantify that fitness.<br><br>\\n\\n    First, I've chosen a list of 32 mathematical operations. I chose this number because it's divisible by 32, which means that they can be \\n    represented in binary easily. Any mutation will affect just one of the bits, switching it to its opposite state. Each formula will be a chain \\n    of fifty of these operations. There are three groups of operators: <br><br>\\n    <ol>\\n        <li><b>Numerals</b> form a <em>term<em> when chained together. When they are followed by another numeral, they concatenate to form a larger term. These include the digits 0 through 9 as well as the decimal. </li>\\n        <li><b>Operators</b> connect two terms. These include addition, subtraction, multiplication, division, expoentiation, modulo, bitwise or, bitwise and, and bitwise xor.</li>\\n        <li><b>Functions</b> operate on the previous term. These include increment, decrement, bitwise left, bitwise right, absolute value, negate, round, ceiling, floor, and zero.</li>\\n        <li><b>Terms</b> are numbers that are terms in and of themselves. These include x and pi.</li>\\n        \\n    </ol>\\n\\n    Here is a list of all the operators and their associated numbers:<br><br>\\n\\n    <table>\\n        <thead>\\n            <tr>\\n                <th>-</th>\\n                <th>0</th>\\n                <th>1</th>\\n                <th>2</th>\\n                <th>3</th>\\n                <th>4</th>\\n                <th>5</th>\\n                <th>6</th>\\n                <th>7</th>\\n            </tr>\\n        </thead>\\n        <tr>\\n            <th>+0</th>\\n            <td>0</td>\\n            <td>1</td>\\n            <td>2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>increment</td>\\n            <td>bitwise left</td>\\n            <td>negate</tr>\\n        <tr>\\n            <th>+8</th>\\n            <td>round</td>\\n            <td>ceiling</td>\\n            <td>input</td>\\n            <td>absolute value</td>\\n            <td>bitwise or</td>\\n            <td>add</td>\\n            <td>multiply</td>\\n            <td>exponent</tr>\\n        <tr>\\n            <th>+16</th>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>8</td>\\n            <td>9</td>\\n            <td>decrement</td>\\n            <td>bitwise right</td>\\n            <td>zero</tr>\\n        <tr>\\n            <th>+24</th>\\n            <td>decimal point</td>\\n            <td>floor</td>\\n            <td>pi</td>\\n            <td>bitwise and</td>\\n            <td>bitwise xor</td>\\n            <td>subtract</td>\\n            <td>divide</td>\\n            <td>remainder</td>\\n        </tr>\\n    </table>\\n\\n    To implement these, we'll use the letters A-Z and the numbers 0-5 to represent each position in the chart. Now we can represent each formula \\n    as a string of letters/numbers, and a string of binary numbers.<br><br>\\n\\n    Now, to turn each genotype into a phenotype, we need to determine which genomes create a valid phenotype. In the event that a genotype is \\n    invalid, then we'll discard it and create a replacement in its place for the next generation. So, which genotypes are valid?<br><br>\\n\\n    There are several ways that the numerals, operators, functions, and terms can combine in a few ways. Here is an example grammar of how these \\n    terms can combine:<br><br>\\n\\n    numeral string = [numeral] | [numeral][numeral string]<br>\\n    decimal string = [numeral string][decimal] | [decimal][numeral string] | [numeral string][decimal][numeral string]<br>\\n    term = [numeral string] | [term][function] |  [term][operator][term]<br><br>\\n\\n    Implementing this grammar, there are a few ways that a genome can create a malformed phenotype. The first character must be a numeral or a \\n    term, and the last character cannot be an operator. If two terms are adjacent and cannot be combined into a numeral string, then that formula \\n    cannot be evaluated (e.g. 123 is valid, but 1pi3 is not because multiplication isn't defined in this way). If there are more than two decimal \\n    points in a number, then that number is invalid. Only a term can follow an operator.<br><br>\\n\\n    Lastly, in order to test the fitness, the formula will be applied to the numbers 1 through 10. Then, the differences between each term will be \\n    taken. Each of these will be divided by 26 and only the remainder kept. From there, the absolute value of the difference between the formula's \\n    result and the difference between the related terms in the target will be taken. That number will then be squared, resulting in a number \\n    between 0 and 169. These differences are calculated for each of the 10 input terms, and then the totals are added together. Here's how the \\n    formula looks:<br><br>\\n\\n    |(x[n] - x[n+1]) - (f(y[n]) - f(y[n+1])| + 52 % 26<br><br>\\n\\n    The lower this score, the better the formula describes the function. The reason that this is implemented based on the difference between terms \\n    is because a formula that is perfectly parallel to the input would show as being less fit than a formula that matches all of the points exept \\n    missing by one, even though the first formula would be an exact match if two was subtracted from it.<br><br>\\n\\n    Now that we have a genotype, phenotype, and fitness functions, we have all the groundwork for our genetic algorithm. From here, we just have to \\n    program the components and then run the algorithm until we get a match!<br><br>\\n    \";\n  document.getElementsByClassName(\"content\")[0].innerHTML = content;\n}"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":8,"column":0},"source":"content/blog/fitness.js","original":{"line":1,"column":0}},{"name":"fitness","generated":{"line":8,"column":9},"source":"content/blog/fitness.js","original":{"line":1,"column":9}},{"generated":{"line":8,"column":16},"source":"content/blog/fitness.js","original":{"line":1,"column":0}},{"generated":{"line":8,"column":19},"source":"content/blog/fitness.js","original":{"line":1,"column":19}},{"generated":{"line":9,"column":0},"source":"content/blog/fitness.js","original":{"line":2,"column":4}},{"name":"content","generated":{"line":9,"column":6},"source":"content/blog/fitness.js","original":{"line":2,"column":8}},{"generated":{"line":9,"column":13},"source":"content/blog/fitness.js","original":{"line":2,"column":15}},{"generated":{"line":9,"column":16},"source":"content/blog/fitness.js","original":{"line":2,"column":18}},{"generated":{"line":9,"column":18},"source":"content/blog/fitness.js","original":{"line":2,"column":4}},{"name":"content","generated":{"line":10,"column":0},"source":"content/blog/fitness.js","original":{"line":4,"column":4}},{"name":"content","generated":{"line":10,"column":2},"source":"content/blog/fitness.js","original":{"line":4,"column":4}},{"generated":{"line":10,"column":9},"source":"content/blog/fitness.js","original":{"line":4,"column":11}},{"generated":{"line":10,"column":7688},"source":"content/blog/fitness.js","original":{"line":4,"column":4}},{"name":"document","generated":{"line":11,"column":0},"source":"content/blog/fitness.js","original":{"line":169,"column":4}},{"name":"document","generated":{"line":11,"column":2},"source":"content/blog/fitness.js","original":{"line":169,"column":4}},{"generated":{"line":11,"column":10},"source":"content/blog/fitness.js","original":{"line":169,"column":12}},{"name":"getElementsByClassName","generated":{"line":11,"column":11},"source":"content/blog/fitness.js","original":{"line":169,"column":13}},{"generated":{"line":11,"column":33},"source":"content/blog/fitness.js","original":{"line":169,"column":4}},{"generated":{"line":11,"column":34},"source":"content/blog/fitness.js","original":{"line":169,"column":36}},{"generated":{"line":11,"column":43},"source":"content/blog/fitness.js","original":{"line":169,"column":4}},{"generated":{"line":11,"column":45},"source":"content/blog/fitness.js","original":{"line":169,"column":47}},{"generated":{"line":11,"column":46},"source":"content/blog/fitness.js","original":{"line":169,"column":4}},{"name":"innerHTML","generated":{"line":11,"column":48},"source":"content/blog/fitness.js","original":{"line":169,"column":50}},{"generated":{"line":11,"column":57},"source":"content/blog/fitness.js","original":{"line":169,"column":4}},{"name":"content","generated":{"line":11,"column":60},"source":"content/blog/fitness.js","original":{"line":169,"column":62}},{"generated":{"line":11,"column":67},"source":"content/blog/fitness.js","original":{"line":169,"column":4}},{"generated":{"line":12,"column":0},"source":"content/blog/fitness.js","original":{"line":170,"column":1}}],"sources":{"content/blog/fitness.js":"function fitness() {\n    let content = \"\";\n\n    content += `   \n    <h3>\n        The Problem to Solve\n    </h3>\n\n    Now that I've given an overview of what a genetic algorithm is, the next question is what problem should we solve?<br><br>\n\n    Finding an equation that describes a curve that passes through a set of points can be a problem that is either trivial to solve or nearly \n    impossible unless you're an experienced mathematician. Choosing those points based on a method that was not determined mathematically can \n    make it difficult if not impossible to find an equation that fits the points. However, with a genetic algorithm, finding such an equation \n    would be (arguably) much easier.<br><br>\n\n    So, what data am I choosing for this example? I'm picking the following sets of (x,y) points:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>x</th>\n                <th>y</th>\n            </tr>\n        </thead>\n        <tr>\n            <td>1</td>\n            <td>8</tr>\n        <tr>\n            <td>2</td>\n            <td>5</tr>\n        <tr>\n            <td>3</td>\n            <td>12</tr>\n        <tr>\n            <td>4</td>\n            <td>12</tr>\n        <tr>\n            <td>5</td>\n            <td>15</tr>\n        <tr>\n            <td>6</td>\n            <td>23</tr>\n        <tr>\n            <td>7</td>\n            <td>15</tr>\n        <tr>\n            <td>8</td>\n            <td>18</tr>\n        <tr>\n            <td>9</td>\n            <td>12</tr>\n        <tr>\n            <td>10</td>\n            <td>4</td>\n        </tr>\n    </table>\n\n    This may seem like a random set of numbers, but if you substitute each number for its associated letter in the alphabet, then you get one \n    of the most famous phrases in computer science: \"HELLOWORLD.\"<br><br>\n\n    To start implementing the algorithm, we need to determine the genotype and phenotype. This will involve a mathematical function, so we'll need \n    a way to represent a function in a way that lends itself to mutation. From there, we'll apply the formula to the numbers 1 through 10 and see \n    how well they match the given set of points. We'll also need a way to quantify that fitness.<br><br>\n\n    First, I've chosen a list of 32 mathematical operations. I chose this number because it's divisible by 32, which means that they can be \n    represented in binary easily. Any mutation will affect just one of the bits, switching it to its opposite state. Each formula will be a chain \n    of fifty of these operations. There are three groups of operators: <br><br>\n    <ol>\n        <li><b>Numerals</b> form a <em>term<em> when chained together. When they are followed by another numeral, they concatenate to form a larger term. These include the digits 0 through 9 as well as the decimal. </li>\n        <li><b>Operators</b> connect two terms. These include addition, subtraction, multiplication, division, expoentiation, modulo, bitwise or, bitwise and, and bitwise xor.</li>\n        <li><b>Functions</b> operate on the previous term. These include increment, decrement, bitwise left, bitwise right, absolute value, negate, round, ceiling, floor, and zero.</li>\n        <li><b>Terms</b> are numbers that are terms in and of themselves. These include x and pi.</li>\n        \n    </ol>\n\n    Here is a list of all the operators and their associated numbers:<br><br>\n\n    <table>\n        <thead>\n            <tr>\n                <th>-</th>\n                <th>0</th>\n                <th>1</th>\n                <th>2</th>\n                <th>3</th>\n                <th>4</th>\n                <th>5</th>\n                <th>6</th>\n                <th>7</th>\n            </tr>\n        </thead>\n        <tr>\n            <th>+0</th>\n            <td>0</td>\n            <td>1</td>\n            <td>2</td>\n            <td>3</td>\n            <td>4</td>\n            <td>increment</td>\n            <td>bitwise left</td>\n            <td>negate</tr>\n        <tr>\n            <th>+8</th>\n            <td>round</td>\n            <td>ceiling</td>\n            <td>input</td>\n            <td>absolute value</td>\n            <td>bitwise or</td>\n            <td>add</td>\n            <td>multiply</td>\n            <td>exponent</tr>\n        <tr>\n            <th>+16</th>\n            <td>5</td>\n            <td>6</td>\n            <td>7</td>\n            <td>8</td>\n            <td>9</td>\n            <td>decrement</td>\n            <td>bitwise right</td>\n            <td>zero</tr>\n        <tr>\n            <th>+24</th>\n            <td>decimal point</td>\n            <td>floor</td>\n            <td>pi</td>\n            <td>bitwise and</td>\n            <td>bitwise xor</td>\n            <td>subtract</td>\n            <td>divide</td>\n            <td>remainder</td>\n        </tr>\n    </table>\n\n    To implement these, we'll use the letters A-Z and the numbers 0-5 to represent each position in the chart. Now we can represent each formula \n    as a string of letters/numbers, and a string of binary numbers.<br><br>\n\n    Now, to turn each genotype into a phenotype, we need to determine which genomes create a valid phenotype. In the event that a genotype is \n    invalid, then we'll discard it and create a replacement in its place for the next generation. So, which genotypes are valid?<br><br>\n\n    There are several ways that the numerals, operators, functions, and terms can combine in a few ways. Here is an example grammar of how these \n    terms can combine:<br><br>\n\n    numeral string = [numeral] | [numeral][numeral string]<br>\n    decimal string = [numeral string][decimal] | [decimal][numeral string] | [numeral string][decimal][numeral string]<br>\n    term = [numeral string] | [term][function] |  [term][operator][term]<br><br>\n\n    Implementing this grammar, there are a few ways that a genome can create a malformed phenotype. The first character must be a numeral or a \n    term, and the last character cannot be an operator. If two terms are adjacent and cannot be combined into a numeral string, then that formula \n    cannot be evaluated (e.g. 123 is valid, but 1pi3 is not because multiplication isn't defined in this way). If there are more than two decimal \n    points in a number, then that number is invalid. Only a term can follow an operator.<br><br>\n\n    Lastly, in order to test the fitness, the formula will be applied to the numbers 1 through 10. Then, the differences between each term will be \n    taken. Each of these will be divided by 26 and only the remainder kept. From there, the absolute value of the difference between the formula's \n    result and the difference between the related terms in the target will be taken. That number will then be squared, resulting in a number \n    between 0 and 169. These differences are calculated for each of the 10 input terms, and then the totals are added together. Here's how the \n    formula looks:<br><br>\n\n    |(x[n] - x[n+1]) - (f(y[n]) - f(y[n+1])| + 52 % 26<br><br>\n\n    The lower this score, the better the formula describes the function. The reason that this is implemented based on the difference between terms \n    is because a formula that is perfectly parallel to the input would show as being less fit than a formula that matches all of the points exept \n    missing by one, even though the first formula would be an exact match if two was subtracted from it.<br><br>\n\n    Now that we have a genotype, phenotype, and fitness functions, we have all the groundwork for our genetic algorithm. From here, we just have to \n    program the components and then run the algorithm until we get a match!<br><br>\n    `;\n\n    document.getElementsByClassName(\"content\")[0].innerHTML = content;\n}\n\nexport {fitness};"},"lineCount":null}},"error":null,"hash":"f36630b6b027b26919cab147d2280967","cacheData":{"env":{}}}